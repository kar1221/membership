SCRIPT  /usr/share/nvim/runtime/ftplugin/vue.vim
Sourced 2 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	vue
                            
    2              0.000012 if exists("b:did_ftplugin") | finish | endif
    2              0.000006 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    2              0.000005 let s:save_cpo = &cpo
    2              0.000019 set cpo-=C
                            
                            " Copied from ftplugin/html.vim
                            " Original thanks to Johannes Zellner and Benji Fisher.
    2              0.000006 if exists("loaded_matchit")
    2              0.000005   let b:match_ignorecase = 1
    2              0.000007   let b:match_words = '<:>,'
                            	\ .. '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,'
                            	\ .. '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,'
                            	\ .. '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    2              0.000004 endif
                            
                            " Restore the saved compatibility options.
    2              0.000008 let &cpo = s:save_cpo
    2              0.000008 unlet s:save_cpo

SCRIPT  /usr/share/nvim/runtime/indent/vue.vim
Sourced 2 times
Total time:   0.001189
 Self time:   0.000329

count  total (s)   self (s)
                            " Vim indent file placeholder
                            " Language:	Vue
                            " Maintainer:	None, please volunteer if you have a real Vue indent script
                            " Last Change:	2022 Dec 24
                            
                            " Only load this indent file when no other was loaded.
    2              0.000005 if exists("b:did_indent")
                               finish
    2              0.000005 endif
                            " don't set b:did_indent, otherwise html indenting won't be activated
                            " let b:did_indent = 1
                            
                            " Html comes closest
    2   0.001129   0.000270 runtime! indent/html.vim

SCRIPT  /usr/share/nvim/runtime/indent/html.vim
Sourced 2 times
Total time:   0.000851
 Self time:   0.000281

count  total (s)   self (s)
                            " Vim indent script for HTML
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Original Author: Andy Wokula <anwoku@yahoo.de>
                            " Last Change:	2023 Aug 13
                            " Version:	1.0 "{{{
                            " Description:	HTML indent script with cached state for faster indenting on a
                            "		range of lines.
                            "		Supports template systems through hooks.
                            "		Supports Closure stylesheets.
                            "
                            " Credits:
                            "	indent/html.vim (2006 Jun 05) from J. Zellner
                            "	indent/css.vim (2006 Dec 20) from N. Weibull
                            "
                            " History:
                            " 2014 June	(v1.0) overhaul (Bram)
                            " 2012 Oct 21	(v0.9) added support for shiftwidth()
                            " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
                            " 2008 Apr 28	(v0.6) revised customization
                            " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
                            "}}}
                            
                            " Init Folklore, check user settings (2nd time ++)
    2              0.000006 if exists("b:did_indent") "{{{
                              finish
    2              0.000002 endif
                            
                            " Load the Javascript indent script first, it defines GetJavascriptIndent().
                            " Undo the rest.
                            " Load base python indent.
    2              0.000007 if !exists('*GetJavascriptIndent')
                              runtime! indent/javascript.vim
    2              0.000004 endif
    2              0.000005 let b:did_indent = 1
                            
    2              0.000026 setlocal indentexpr=HtmlIndent()
    2              0.000006 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
                            
                            " Needed for % to work when finding start/end of a tag.
    2              0.000009 setlocal matchpairs+=<:>
                            
    2              0.000004 let b:undo_indent = "setlocal inde< indk<"
                            
                            " b:hi_indent keeps state to speed up indenting consecutive lines.
    2              0.000007 let b:hi_indent = {"lnum": -1}
                            
                            """""" Code below this is loaded only once. """""
    2              0.000007 if exists("*HtmlIndent") && !exists('g:force_reload_html')
    2   0.000592   0.000023   call HtmlIndent_CheckUserSettings()
    2              0.000004   finish
                            endif
                            
                            " Allow for line continuation below.
                            let s:cpo_save = &cpo
                            set cpo-=C
                            "}}}
                            
                            " Pattern to match the name of a tag, including custom elements.
                            let s:tagname = '\w\+\(-\w\+\)*'
                            
                            " Check and process settings from b:html_indent and g:html_indent... variables.
                            " Prefer using buffer-local settings over global settings, so that there can
                            " be defaults for all HTML files and exceptions for specific types of HTML
                            " files.
                            func HtmlIndent_CheckUserSettings()
                              "{{{
                              let inctags = ''
                              if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
                              let b:hi_tags = {}
                              if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
                              let autotags = ''
                              if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
                              let b:hi_removed_tags = {}
                              if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
                              let string_names = []
                              if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
                              let b:hi_insideStringNames = ['htmlString']
                              if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
                              let tag_names = []
                              if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
                              let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
                              if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
                              let indone = {"zero": 0
                                          \,"auto": "indent(prevnonblank(v:lnum-1))"
                                          \,"inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
                              let script1 = ''
                              if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
                                let script1 = g:html_indent_script1
                              endif
                              if len(script1) > 0
                                let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
                                let b:hi_js1indent = 0
                              endif
                            
                              let style1 = ''
                              if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
                              if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
                                let b:hi_css1indent = 0
                              endif
                            
                              if !exists('b:html_indent_line_limit')
                                if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
                                  let b:html_indent_line_limit = 200
                                endif
                              endif
                            
                              if exists('b:html_indent_attribute')
                                let b:hi_attr_indent = b:html_indent_attribute
                              elseif exists('g:html_indent_attribute')
                                let b:hi_attr_indent = g:html_indent_attribute
                              else
                                let b:hi_attr_indent = 2
                              endif
                            
                            endfunc "}}}
                            
                            " Init Script Vars
                            "{{{
                            let b:hi_lasttick = 0
                            let b:hi_newstate = {}
                            let s:countonly = 0
                             "}}}
                            
                            " Fill the s:indent_tags dict with known tags.
                            " The key is "tagname" or "/tagname".  {{{
                            " The value is:
                            " 1   opening tag
                            " 2   "pre"
                            " 3   "script"
                            " 4   "style"
                            " 5   comment start
                            " 6   conditional comment start
                            " -1  closing tag
                            " -2  "/pre"
                            " -3  "/script"
                            " -4  "/style"
                            " -5  comment end
                            " -6  conditional comment end
                            let s:indent_tags = {}
                            let s:endtags = [0,0,0,0,0,0,0]   " long enough for the highest index
                            "}}}
                            
                            " Add a list of tag names for a pair of <tag> </tag> to "tags".
                            func s:AddITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = -1
                              endfor
                            endfunc "}}}
                            
                            " Take a list of tag name pairs that are not to be used as tag pairs.
                            func s:RemoveITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = 1
                              endfor
                            endfunc "}}}
                            
                            " Add a block tag, that is a tag with a different kind of indenting.
                            func s:AddBlockTag(tag, id, ...)
                              "{{{
                              if !(a:id >= 2 && a:id < len(s:endtags))
                                echoerr 'AddBlockTag ' . a:id
                                return
                              endif
                              let s:indent_tags[a:tag] = a:id
                              if a:0 == 0
                                let s:indent_tags['/' . a:tag] = -a:id
                                let s:endtags[a:id] = "</" . a:tag . ">"
                              else
                                let s:indent_tags[a:1] = -a:id
                                let s:endtags[a:id] = a:1
                              endif
                            endfunc "}}}
                            
                            " Add known tag pairs.
                            " Self-closing tags and tags that are sometimes {{{
                            " self-closing (e.g., <p>) are not here (when encountering </p> we can find
                            " the matching <p>, but not the other way around).
                            " Known self-closing tags: " 'p', 'img', 'source', 'area', 'keygen', 'track',
                            " 'wbr'.
                            " Old HTML tags:
                            call s:AddITags(s:indent_tags, [
                                \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
                                \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
                                \ 'colgroup', 'dd', 'del', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'font',
                                \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
                                \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
                                \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
                                \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
                                \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
                                \ 'tr', 'tbody', 'tfoot', 'thead'])
                            
                            " New HTML5 elements:
                            call s:AddITags(s:indent_tags, [
                                \ 'article', 'aside', 'audio', 'bdi', 'canvas', 'command', 'data',
                                \ 'datalist', 'details', 'dialog', 'embed', 'figcaption', 'figure',
                                \ 'footer', 'header', 'hgroup', 'main', 'mark', 'meter', 'nav', 'output',
                                \ 'picture', 'progress', 'rp', 'rt', 'ruby', 'section', 'summary',
                                \ 'svg', 'time', 'video'])
                            
                            " Tags added for web components:
                            call s:AddITags(s:indent_tags, [
                                \ 'content', 'shadow', 'template'])
                            "}}}
                            
                            " Add Block Tags: these contain alien content
                            "{{{
                            call s:AddBlockTag('pre', 2)
                            call s:AddBlockTag('script', 3)
                            call s:AddBlockTag('style', 4)
                            call s:AddBlockTag('<!--', 5, '-->')
                            call s:AddBlockTag('<!--[', 6, '![endif]-->')
                            "}}}
                            
                            " Return non-zero when "tagname" is an opening tag, not being a block tag, for
                            " which there should be a closing tag.  Can be used by scripts that include
                            " HTML indenting.
                            func HtmlIndent_IsOpenTag(tagname)
                              "{{{
                              if get(s:indent_tags, a:tagname) == 1
                                return 1
                              endif
                              return get(b:hi_tags, a:tagname) == 1
                            endfunc "}}}
                            
                            " Get the value for "tagname", taking care of buffer-local tags.
                            func s:get_tag(tagname)
                              "{{{
                              let i = get(s:indent_tags, a:tagname)
                              if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
                              endif
                              if i == 0
                                let i = get(b:hi_tags, a:tagname)
                              endif
                              return i
                            endfunc "}}}
                            
                            " Count the number of start and end tags in "text".
                            func s:CountITags(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                              let s:block = 0		" assume starting outside of a block
                              let s:countonly = 1	" don't change state
                              call substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              let s:countonly = 0
                            endfunc "}}}
                            
                            " Count the number of start and end tags in text.
                            func s:CountTagsAndState(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
                              let s:block = b:hi_newstate.block
                              let tmp = substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
                              let b:hi_newstate.block = s:block
                            endfunc "}}}
                            
                            " Used by s:CountITags() and s:CountTagsAndState().
                            func s:CheckTag(itag)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
                              if (s:CheckCustomTag(a:itag))
                                return ""
                              endif
                              let ind = s:get_tag(a:itag)
                              if ind == -1
                                " closing tag
                                if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              elseif ind == 1
                                " opening tag
                                if s:block != 0
                                  return ""
                                endif
                                let s:nextrel += 1
                              elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag(). Returns an empty string or "SCRIPT".
                            func s:CheckBlockTag(blocktag, ind)
                              "{{{
                              if a:ind > 0
                                " a block starts here
                                if s:block != 0
                                  " already in a block (nesting) - ignore
                                  " especially ignore comments after other blocktags
                                  return ""
                                endif
                                let s:block = a:ind		" block type
                                if s:countonly
                                  return ""
                                endif
                                let b:hi_newstate.blocklnr = v:lnum
                                " save allover indent for the endtag
                                let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * shiftwidth()
                                if a:ind == 3
                                  return "SCRIPT"    " all except this must be lowercase
                                  " line is to be checked again for the type attribute
                                endif
                              else
                                let s:block = 0
                                " we get here if starting and closing a block-tag on the same line
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag().
                            func s:CheckCustomTag(ctag)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
                              let pattern = '\%\(\w\+-\)\+\w\+'
                              if match(a:ctag, pattern) == -1
                                return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1
                            endfunc "}}}
                            
                            " Return the <script> type: either "javascript" or ""
                            func s:GetScriptType(str)
                              "{{{
                              if a:str == "" || a:str =~ "java"
                                return "javascript"
                              else
                                return ""
                              endif
                            endfunc "}}}
                            
                            " Look back in the file, starting at a:lnum - 1, to compute a state for the
                            " start of line a:lnum.  Return the new state.
                            func s:FreshState(lnum)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
                              let state = {}
                              let state.lnum = prevnonblank(a:lnum - 1)
                              let state.scripttype = ""
                              let state.blocktagind = -1
                              let state.block = 0
                              let state.baseindent = 0
                              let state.blocklnr = 0
                              let state.inattr = 0
                            
                              if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
                              let stopline2 = v:lnum + 1
                              if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
                              let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
                              if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
                              endif
                              if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
                              let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
                              if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
                              endif
                            
                              " else within usual HTML
                              let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
                              let comcol = stridx(text, '-->')
                              if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
                              let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
                              if !swendtag && text =~ '</' . s:tagname . '\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * shiftwidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * shiftwidth()
                                    endif
                                  endif
                                  return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
                              let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
                              let text = getline(state.lnum)
                              let swendtag = match(text, '^\s*</') >= 0
                              call s:CountITags(tolower(text))
                              let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
                              if !swendtag
                                let state.baseindent += s:curind * shiftwidth()
                              endif
                              return state
                            endfunc "}}}
                            
                            " Indent inside a <pre> block: Keep indent as-is.
                            func s:Alien2()
                              "{{{
                              return -1
                            endfunc "}}}
                            
                            " Return the indent inside a <script> block for javascript.
                            func s:Alien3()
                              "{{{
                              let lnum = prevnonblank(v:lnum - 1)
                              while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
                                " Skip over comments to avoid that cindent() aligns with the <script> tag
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              if lnum < b:hi_indent.blocklnr
                                " indent for <script> itself
                                return b:hi_indent.blocktagind
                              endif
                              if lnum == b:hi_indent.blocklnr
                                " indent for the first line after <script>
                                return eval(b:hi_js1indent)
                              endif
                              if b:hi_indent.scripttype == "javascript"
                                " indent for further lines
                                return GetJavascriptIndent()
                              else
                                return -1
                              endif
                            endfunc "}}}
                            
                            " Return the indent inside a <style> block.
                            func s:Alien4()
                              "{{{
                              if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
                                " indent for first content line
                                return eval(b:hi_css1indent)
                              endif
                              return s:CSSIndent()
                            endfunc "}}}
                            
                            " Indending inside a <style> block.  Returns the indent.
                            func s:CSSIndent()
                              "{{{
                              " This handles standard CSS and also Closure stylesheets where special lines
                              " start with @.
                              " When the line starts with '*' or the previous line starts with "/*"
                              " and does not end in "*/", use C indenting to format the comment.
                              " Adopted $VIMRUNTIME/indent/css.vim
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*[*]'
                                    \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
                                    \     && getline(v:lnum - 1) !~ '\*/\s*$')
                                return cindent(v:lnum)
                              endif
                            
                              let min_lnum = b:hi_indent.blocklnr
                              let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
                              let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
                              if prev_lnum <= min_lnum
                                " Just below the <style> tag, indent for first content line after comments.
                                return eval(b:hi_css1indent)
                              endif
                            
                              " If the current line starts with "}" align with its match.
                              if curtext =~ '^\s*}'
                                call cursor(v:lnum, 1)
                                try
                                  normal! %
                                  " Found the matching "{", align with it after skipping unfinished lines.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  return indent(align_lnum)
                                catch
                                  " can't find it, try something else, but it's most likely going to be
                                  " wrong
                                endtry
                              endif
                            
                              " add indent after {
                              let brace_counts = HtmlIndent_CountBraces(prev_lnum)
                              let extra = brace_counts.c_open * shiftwidth()
                            
                              let prev_text = getline(prev_lnum)
                              let below_end_brace = prev_text =~ '}\s*$'
                            
                              " Search back to align with the first line that's unfinished.
                              let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)
                            
                              " Handle continuation lines if aligning with previous line and not after a
                              " "}".
                              if extra == 0 && align_lnum == prev_lnum && !below_end_brace
                                let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
                                let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
                                if curtext =~ '^\s*\(/\*\|@\)'
                                  " if the current line is not a comment or starts with @ (used by template
                                  " systems) reduce indent if previous line is a continuation line
                                  if !prev_hasfield && !prev_special
                                    let extra = -shiftwidth()
                                  endif
                                else
                                  let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
                                  let prev_unfinished = s:CssUnfinished(prev_text)
                                  if prev_unfinished
                                    " Continuation line has extra indent if the previous line was not a
                                    " continuation line.
                                    let extra = shiftwidth()
                                    " Align with @if
                                    if prev_text =~ '^\s*@if '
                                      let extra = 4
                                    endif
                                  elseif cur_hasfield && !prev_hasfield && !prev_special
                                    " less indent below a continuation line
                                    let extra = -shiftwidth()
                                  endif
                                endif
                              endif
                            
                              if below_end_brace
                                " find matching {, if that line starts with @ it's not the start of a rule
                                " but something else from a template system
                                call cursor(prev_lnum, 1)
                                call search('}\s*$')
                                try
                                  normal! %
                                  " Found the matching "{", align with it.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  let special = getline(align_lnum) =~ '^\s*@'
                                catch
                                  let special = 0
                                endtry
                                if special
                                  " do not reduce indent below @{ ... }
                                  if extra < 0
                                    let extra += shiftwidth()
                                  endif
                                else
                                  let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * shiftwidth()
                                endif
                              endif
                            
                              " if no extra indent yet...
                              if extra == 0
                                if brace_counts.p_open > brace_counts.p_close
                                  " previous line has more ( than ): add a shiftwidth
                                  let extra = shiftwidth()
                                elseif brace_counts.p_open < brace_counts.p_close
                                  " previous line has more ) than (: subtract a shiftwidth
                                  let extra = -shiftwidth()
                                endif
                              endif
                            
                              return indent(align_lnum) + extra
                            endfunc "}}}
                            
                            " Inside <style>: Whether a line is unfinished.
                            " 	tag:
                            " 	tag: blah
                            " 	tag: blah &&
                            " 	tag: blah ||
                            func s:CssUnfinished(text)
                              "{{{
                              return a:text =~ '\(||\|&&\|:\|\k\)\s*$'
                            endfunc "}}}
                            
                            " Search back for the first unfinished line above "lnum".
                            func s:CssFirstUnfinished(lnum, min_lnum)
                              "{{{
                              let align_lnum = a:lnum
                              while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
                                let align_lnum -= 1
                              endwhile
                              return align_lnum
                            endfunc "}}}
                            
                            " Find the non-empty line at or before "lnum" that is not a comment.
                            func s:CssPrevNonComment(lnum, stopline)
                              "{{{
                              " caller starts from a line a:lnum + 1 that is not a comment
                              let lnum = prevnonblank(a:lnum)
                              while 1
                                let ccol = match(getline(lnum), '\*/')
                                if ccol < 0
                                  " No comment end thus it's something else.
                                  return lnum
                                endif
                                call cursor(lnum, ccol + 1)
                                " Search back for the /* that starts the comment
                                let lnum = search('/\*', 'bW', a:stopline)
                                if indent(".") == virtcol(".") - 1
                                  " The  found /* is at the start of the line. Now go back to the line
                                  " above it and again check if it is a comment.
                                  let lnum = prevnonblank(lnum - 1)
                                else
                                  " /* is after something else, thus it's not a comment line.
                                  return lnum
                                endif
                              endwhile
                            endfunc "}}}
                            
                            " Check the number of {} and () in line "lnum". Return a dict with the counts.
                            func HtmlIndent_CountBraces(lnum)
                              "{{{
                              let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
                              let c_open = 0
                              let c_close = 0
                              let p_open = 0
                              let p_close = 0
                              for brace in split(brs, '\zs')
                                if brace == "{"
                                  let c_open += 1
                                elseif brace == "}"
                                  if c_open > 0
                                    let c_open -= 1
                                  else
                                    let c_close += 1
                                  endif
                                elseif brace == '('
                                  let p_open += 1
                                elseif brace == ')'
                                  if p_open > 0
                                    let p_open -= 1
                                  else
                                    let p_close += 1
                                  endif
                                endif
                              endfor
                              return {'c_open': c_open,
                                    \ 'c_close': c_close,
                                    \ 'p_open': p_open,
                                    \ 'p_close': p_close}
                            endfunc "}}}
                            
                            " Return the indent for a comment: <!-- -->
                            func s:Alien5()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*\zs-->'
                                " current line starts with end of comment, line up with comment start.
                                call cursor(v:lnum, 0)
                                let lnum = search('<!--', 'b')
                                if lnum > 0
                                  " TODO: what if <!-- is not at the start of the line?
                                  return indent(lnum)
                                endif
                            
                                " Strange, can't find it.
                                return -1
                              endif
                            
                              let prevlnum = prevnonblank(v:lnum - 1)
                              let prevtext = getline(prevlnum)
                              let idx = match(prevtext, '^\s*\zs<!--')
                              if idx >= 0
                                " just below comment start, add a shiftwidth
                                return indent(prevlnum) + shiftwidth()
                              endif
                            
                              " Some files add 4 spaces just below a TODO line.  It's difficult to detect
                              " the end of the TODO, so let's not do that.
                            
                              " Align with the previous non-blank line.
                              return indent(prevlnum)
                            endfunc "}}}
                            
                            " Return the indent for conditional comment: <!--[ ![endif]-->
                            func s:Alien6()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '\s*\zs<!\[endif\]-->'
                                " current line starts with end of comment, line up with comment start.
                                let lnum = search('<!--', 'bn')
                                if lnum > 0
                                  return indent(lnum)
                                endif
                              endif
                              return b:hi_indent.baseindent + shiftwidth()
                            endfunc "}}}
                            
                            " When the "lnum" line ends in ">" find the line containing the matching "<".
                            func HtmlIndent_FindTagStart(lnum)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
                              let idx = match(getline(a:lnum), '\S>\s*$')
                              if idx > 0
                                call cursor(a:lnum, idx)
                                let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
                                if lnum > 0
                                  return [lnum, 1]
                                endif
                              endif
                              return [a:lnum, 0]
                            endfunc "}}}
                            
                            " Find the unclosed start tag from the current cursor position.
                            func HtmlIndent_FindStartTag()
                              "{{{
                              " The cursor must be on or before a closing tag.
                              " If found, positions the cursor at the match and returns the line number.
                              " Otherwise returns 0.
                              let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs' . s:tagname . '\ze')
                              let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
                              if start_lnum > 0
                                return start_lnum
                              endif
                              return 0
                            endfunc "}}}
                            
                            " Moves the cursor from a "<" to the matching ">".
                            func HtmlIndent_FindTagEnd()
                              "{{{
                              " Call this with the cursor on the "<" of a start tag.
                              " This will move the cursor to the ">" of the matching end tag or, when it's
                              " a self-closing tag, to the matching ">".
                              " Limited to look up to b:html_indent_line_limit lines away.
                              let text = getline('.')
                              let tagname = matchstr(text, s:tagname . '\|!--', col('.'))
                              if tagname == '!--'
                                call search('--\zs>')
                              elseif s:get_tag('/' . tagname) != 0
                                " tag with a closing tag, find matching "</tag>"
                                call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
                              else
                                " self-closing tag, find the ">"
                                call search('\S\zs>')
                              endif
                            endfunc "}}}
                            
                            " Indenting inside a start tag. Return the correct indent or -1 if unknown.
                            func s:InsideTag(foundHtmlString)
                              "{{{
                              if a:foundHtmlString
                                " Inside an attribute string.
                                " Align with the opening quote or use an external function.
                                let lnum = v:lnum - 1
                                if lnum > 1
                                  if exists('b:html_indent_tag_string_func')
                                    return b:html_indent_tag_string_func(lnum)
                                  endif
                                  " If there is a double quote in the previous line, indent with the
                                  " character after it.
                                  if getline(lnum) =~ '"'
                            	call cursor(lnum, 0)
                            	normal f"
                            	return virtcol('.')
                                  endif
                                  return indent(lnum)
                                endif
                              endif
                            
                              " Should be another attribute: " attr="val".  Align with the previous
                              " attribute start.
                              let lnum = v:lnum
                              while lnum > 1
                                let lnum -= 1
                                let text = getline(lnum)
                                " Find a match with one of these, align with "attr":
                                "       attr=
                                "  <tag attr=
                                "  text<tag attr=
                                "  <tag>text</tag>text<tag attr=
                                " For long lines search for the first match, finding the last match
                                " gets very slow.
                                if len(text) < 300
                                  let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
                                else
                                  let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
                                endif
                                if idx == -1
                                  " try <tag attr
                                  let idx = match(text, '<' . s:tagname . '\s\+\zs\w')
                                endif
                                if idx == -1
                                  " after just "<tag" indent two levels more by default
                                  let idx = match(text, '<' . s:tagname . '$')
                                  if idx >= 0
                            	call cursor(lnum, idx + 1)
                            	return virtcol('.') - 1 + shiftwidth() * b:hi_attr_indent
                                  endif
                                endif
                                if idx > 0
                                  " Found the attribute to align with.
                                  call cursor(lnum, idx)
                                  return virtcol('.')
                                endif
                              endwhile
                              return -1
                            endfunc "}}}
                            
                            " THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
                            func HtmlIndent()
                              "{{{
                              if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
                              let curtext = tolower(getline(v:lnum))
                              let indentunit = shiftwidth()
                            
                              let b:hi_newstate = {}
                              let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
                              if curtext !~ '^\s*<'
                                normal! ^
                                let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
                                let foundHtmlString = 0
                                for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
                                endfor
                              endif
                            
                              " does the line start with a closing tag?
                              let swendtag = match(curtext, '^\s*</') >= 0
                            
                              if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
                              else
                                " start over (know nothing)
                                let b:hi_indent = s:FreshState(v:lnum)
                              endif
                            
                              if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
                                let b:hi_newstate.block = b:hi_indent.block
                                if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * shiftwidth()
                                      if !swendtag
                                        let indent += s:curind * shiftwidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
                                else
                                  call s:CountTagsAndState(curtext)
                                  let indent = b:hi_indent.baseindent
                                  let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
                                endif
                              endif
                            
                              let b:hi_lasttick = b:changedtick
                              call extend(b:hi_indent, b:hi_newstate, "force")
                              return indent
                            endfunc "}}}
                            
                            " Check user settings when loading this script the first time.
                            call HtmlIndent_CheckUserSettings()
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: fdm=marker ts=8 sw=2 tw=78

FUNCTION  1()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:22
Called 5 times
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
    5              0.000046   if self.owner == a:jobid
    5              0.000034     let self.owner = 0
    5              0.000014   endif
                              " Don't print if exit code is >= 128 ( exit is 128+SIGNUM if by signal (e.g. 143 on SIGTERM))
    5              0.000012   if a:data > 0 && a:data < 128
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
    5              0.000011   endif

FUNCTION  2()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:270
Called 66 times
Total time:   0.756765
 Self time:   0.007557

count  total (s)   self (s)
   66              0.000296   if s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
   66              0.000129   end
                            
   66   0.750737   0.001529   let clipboard_data = type(s:paste[a:reg]) == v:t_func ? s:paste[a:reg]() : s:try_cmd(s:paste[a:reg])
   66              0.003712   if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0 && type(clipboard_data) == v:t_list && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
   66              0.000310     return s:selections[a:reg].data
                              end
                              return clipboard_data

FUNCTION  3()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:286
Called 5 times
Total time:   0.025006
 Self time:   0.025006

count  total (s)   self (s)
    5              0.000023   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    5              0.000006   end
                            
    5              0.000030   if s:cache_enabled == 0 || type(s:copy[a:reg]) == v:t_func
                                if type(s:copy[a:reg]) == v:t_func
                                  call s:copy[a:reg](a:lines, a:regtype)
                                else
                                  call s:try_cmd(s:copy[a:reg], a:lines)
                                endif
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
    5              0.000009   end
                            
    5              0.000018   if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
    5              0.000009   end
    5              0.000033   let s:selections[a:reg] = copy(s:selection)
    5              0.000014   let selection = s:selections[a:reg]
    5              0.000018   let selection.data = [a:lines, a:regtype]
    5              0.000015   let selection.argv = s:copy[a:reg]
    5              0.000012   let selection.detach = s:cache_enabled
    5              0.000018   let selection.cwd = "/"
    5              0.023777   let jobid = jobstart(selection.argv, selection)
    5              0.000036   if jobid > 0
    5              0.000087     call jobsend(jobid, a:lines)
    5              0.000031     call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
    5              0.000038     if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
    5              0.000014     endif
    5              0.000031     let selection.owner = jobid
    5              0.000014     let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
    5              0.000014   endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
    5              0.000025   if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
    5              0.000013   endif
                            
    5              0.000030   return ret

FUNCTION  <SNR>29_GuiCursorMoved()
    Defined: /usr/share/nvim-qt/runtime/plugin/nvim_gui_shim.vim:241
Called 220 times
Total time:   0.018686
 Self time:   0.007644

count  total (s)   self (s)
  220              0.000813 	let l:minLineVisible = line('w0')
  220              0.000616 	let l:bufferSize = line('$')
  220              0.001149 	let l:windowHeight = winheight(winnr())
  220   0.013971   0.002929 	call s:notify_all_uis('Gui', 'CursorMoved', l:minLineVisible, l:bufferSize, l:windowHeight)

FUNCTION  TbGoToBuf()
    Defined: Lua:0
Called 1 time
Total time:   0.144748
 Self time:   0.009876

count  total (s)   self (s)
    1   0.144741   0.009869     call luaeval('require("nvchad.tabufline").goto_buf(_A)', a:bufnr)

FUNCTION  <SNR>29_notify_all_uis()
    Defined: /usr/share/nvim-qt/runtime/plugin/nvim_gui_shim.vim:19
Called 233 times
Total time:   0.011662
 Self time:   0.011662

count  total (s)   self (s)
  466              0.003612 	for ui in nvim_list_uis()
  233              0.003627 		call call("rpcnotify", [ui.chan] + a:000)
  466              0.001082 	endfor

FUNCTION  <SNR>21_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:45
Called 430 times
Total time:   0.126544
 Self time:   0.114137

count  total (s)   self (s)
  430              0.003449   if !exists("w:matchparen_ids")
    1              0.000002     let w:matchparen_ids = []
  430              0.001137   endif
                              " Remove any previous match.
  430   0.016722   0.004316   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  430              0.002375   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  430              0.000811   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  430              0.001777   let c_lnum = line('.')
  430              0.001386   let c_col = col('.')
  430              0.000974   let before = 0
                            
  430              0.001598   let text = getline(c_lnum)
  430              0.002790   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  430              0.001590   let c = text->strpart(c_col - 1)->slice(0, 1)
  430              0.006808   let plist = split(&matchpairs, '.\zs[:,]')
  430              0.001494   let i = index(plist, c)
  430              0.000988   if i < 0
                                " not found, in Insert mode try character before the cursor
  366              0.001359     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  180              0.000589       let before = strlen(c_before)
  180              0.000399       let c = c_before
  180              0.000489       let i = index(plist, c)
  366              0.000748     endif
  366              0.000801     if i < 0
                                  " not found, nothing to do
  357              0.000816       return
    9              0.000018     endif
   73              0.000129   endif
                            
                              " Figure out the arguments for searchpairpos().
   73              0.000158   if i % 2 == 0
   20              0.000045     let s_flags = 'nW'
   20              0.000058     let c2 = plist[i + 1]
   53              0.000104   else
   53              0.000120     let s_flags = 'nbW'
   53              0.000156     let c2 = c
   53              0.000154     let c = plist[i - 1]
   73              0.000127   endif
   73              0.000184   if c == '['
                                let c = '\['
                                let c2 = '\]'
   73              0.000122   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   73              0.000148   if before > 0
    9              0.000039     let save_cursor = getcurpos()
    9              0.000032     call cursor(c_lnum, c_col - before)
    9              0.000042     defer setpos('.', save_cursor)
   73              0.000127   endif
                            
   73              0.000384   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   73              0.000272   elseif exists("b:ts_highlight") && &syntax != 'on'
   73              0.000304     let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
   73              0.000132   endif
                            
                              " Limit the search to lines visible in the window.
   73              0.000384   let stoplinebottom = line('w$')
   73              0.000201   let stoplinetop = line('w0')
   73              0.000159   if i % 2 == 0
   20              0.000044     let stopline = stoplinebottom
   53              0.000090   else
   53              0.000141     let stopline = stoplinetop
   73              0.000129   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   73              0.000209   if mode() == 'i' || mode() == 'R'
   49              0.000235     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   24              0.000046   else
   24              0.000133     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   73              0.000133   endif
   73              0.000141   try
   73              0.026369     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   73              0.000158   endtry
                            
                              " If a match is found setup match highlighting.
   73              0.000230   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
   73              0.000178     if !g:matchparen_disable_cursor_hl
   73              0.000636       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
   73              0.000141     endif
   73              0.000182     let w:paren_hl_on = 1
   73              0.000137   endif

FUNCTION  <SNR>21_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:203
Called 466 times
Total time:   0.013701
 Self time:   0.013701

count  total (s)   self (s)
  466              0.002162   if exists('w:paren_hl_on') && w:paren_hl_on
  146              0.000474     while !empty(w:matchparen_ids)
   73              0.000528       silent! call remove(w:matchparen_ids, 0)->matchdelete()
  146              0.000357     endwhile
   73              0.000232     let w:paren_hl_on = 0
  466              0.000933   endif

FUNCTION  provider#clipboard#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:344
Called 71 times
Total time:   0.787226
 Self time:   0.005455

count  total (s)   self (s)
   71              0.000777   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
   71              0.000191   endif
   71              0.000348   let s:here = v:true
   71              0.000182   try
   71   0.783430   0.001659     return call(s:clipboard[a:method],a:args,s:clipboard)
   71              0.000243   finally
   71              0.000230     let s:here = v:false
   71              0.000267   endtry

FUNCTION  <SNR>32_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:27
Called 44 times
Total time:   0.030737
 Self time:   0.030737

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   44              0.000234   syn clear
   44              0.000148   if exists("b:current_syntax")
                                unlet b:current_syntax
   44              0.000091   endif
                            
   44              0.000205   0verbose let s = expand("<amatch>")
   44              0.000126   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   44              0.000097   elseif s == "OFF"
                                let s = ""
   44              0.000072   endif
                            
   44              0.000082   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   70              0.000283     for name in split(s, '\.')
   35              0.000121       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   35              0.026085         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   35              0.000082       endif
   70              0.000141     endfor
   44              0.000085   endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:14
Called 44 times
Total time:   0.019471
 Self time:   0.018273

count  total (s)   self (s)
   44              0.000142     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   44              0.000072     endif
   44              0.000150     let s = expand("<amatch>")
   44              0.000129     if s != ""
   44              0.000104       if exists("b:did_indent")
                            	unlet b:did_indent
   44              0.000075       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   88              0.000253       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   44   0.016475   0.015277         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   88              0.000252       endfor
   44              0.000084     endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:15
Called 44 times
Total time:   0.056735
 Self time:   0.056570

count  total (s)   self (s)
   44              0.000335     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   44              0.000114     endif
                            
   44              0.000309     let s = expand("<amatch>")
   44              0.000142     if s != ""
   44              0.000285       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   44              0.000087       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   88              0.000400       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   44   0.052132   0.051967         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   88              0.000439       endfor
   44              0.000087     endif

FUNCTION  nvim_treesitter#indent()
    Defined: ~/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim:25
Called 7 times
Total time:   0.003228
 Self time:   0.003228

count  total (s)   self (s)
    7              0.003178 	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))

FUNCTION  HtmlIndent_CheckUserSettings()
    Defined: /usr/share/nvim/runtime/indent/html.vim:65
Called 2 times
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
                              "{{{
    2              0.000006   let inctags = ''
    2              0.000005   if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
    2              0.000006   elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
    2              0.000004   endif
    2              0.000005   let b:hi_tags = {}
    2              0.000006   if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
    2              0.000002   endif
                            
    2              0.000005   let autotags = ''
    2              0.000005   if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
    2              0.000005   elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
    2              0.000004   endif
    2              0.000004   let b:hi_removed_tags = {}
    2              0.000005   if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
    2              0.000005   endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
    2              0.000005   let string_names = []
    2              0.000005   if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
    2              0.000005   elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
    2              0.000004   endif
    2              0.000005   let b:hi_insideStringNames = ['htmlString']
    2              0.000004   if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
    2              0.000002   endif
                            
                              " Syntax names indicating being inside a tag.
    2              0.000002   let tag_names = []
    2              0.000005   if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
    2              0.000005   elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
    2              0.000004   endif
    2              0.000005   let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
    2              0.000005   if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
    2              0.000002   endif
                            
    2              0.000006   let indone = {"zero": 0,"auto": "indent(prevnonblank(v:lnum-1))","inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
    2              0.000005   let script1 = ''
    2              0.000005   if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
    2              0.000006   elseif exists("g:html_indent_script1")
    2              0.000005     let script1 = g:html_indent_script1
    2              0.000004   endif
    2              0.000005   if len(script1) > 0
    2              0.000009     let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
                                let b:hi_js1indent = 0
    2              0.000002   endif
                            
    2              0.000004   let style1 = ''
    2              0.000004   if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
    2              0.000005   elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
    2              0.000002   endif
    2              0.000005   if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
    2              0.000004   else
    2              0.000005     let b:hi_css1indent = 0
    2              0.000004   endif
                            
    2              0.000005   if !exists('b:html_indent_line_limit')
    2              0.000005     if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
    2              0.000004     else
    2              0.000004       let b:html_indent_line_limit = 200
    2              0.000004     endif
    2              0.000002   endif
                            
    2              0.000005   if exists('b:html_indent_attribute')
                                let b:hi_attr_indent = b:html_indent_attribute
    2              0.000005   elseif exists('g:html_indent_attribute')
                                let b:hi_attr_indent = g:html_indent_attribute
    2              0.000004   else
    2              0.000006     let b:hi_attr_indent = 2
    2              0.000004   endif
                            

FUNCTION  <SNR>36_try_cmd()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:38
Called 66 times
Total time:   0.749208
 Self time:   0.008393

count  total (s)   self (s)
   66   0.745227   0.004412   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
   66              0.000736   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
   66              0.000127   endif
   66              0.000281   return out

FUNCTION  <SNR>30_dopopd()
    Defined: /usr/share/vim/vimfiles/plugin/fzf.vim:638
Called 12 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
   12              0.000038   if !exists('w:fzf_pushd')
   12              0.000023     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  GuiClose()
    Defined: /usr/share/nvim-qt/runtime/plugin/nvim_gui_shim.vim:26
Called 1 time
Total time:   0.000075
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000071   0.000017   call s:notify_all_uis('Gui', 'Close', v:exiting)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   71   0.787226   0.005455  provider#clipboard#Call()
   66   0.756765   0.007557  2()
   66   0.749208   0.008393  <SNR>36_try_cmd()
    1   0.144748   0.009876  TbGoToBuf()
  430   0.126544   0.114137  <SNR>21_Highlight_Matching_Pair()
   44   0.056735   0.056570  <SNR>1_LoadFTPlugin()
   44   0.030737             <SNR>32_SynSet()
    5   0.025006             3()
   44   0.019471   0.018273  <SNR>2_LoadIndent()
  220   0.018686   0.007644  <SNR>29_GuiCursorMoved()
  466   0.013701             <SNR>21_Remove_Matches()
  233   0.011662             <SNR>29_notify_all_uis()
    7   0.003228             nvim_treesitter#indent()
    2   0.000571             HtmlIndent_CheckUserSettings()
    5   0.000271             1()
   12   0.000134             <SNR>30_dopopd()
    1   0.000075   0.000020  GuiClose()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  430   0.126544   0.114137  <SNR>21_Highlight_Matching_Pair()
   44   0.056735   0.056570  <SNR>1_LoadFTPlugin()
   44              0.030737  <SNR>32_SynSet()
    5              0.025006  3()
   44   0.019471   0.018273  <SNR>2_LoadIndent()
  466              0.013701  <SNR>21_Remove_Matches()
  233              0.011662  <SNR>29_notify_all_uis()
    1   0.144748   0.009876  TbGoToBuf()
   66   0.749208   0.008393  <SNR>36_try_cmd()
  220   0.018686   0.007644  <SNR>29_GuiCursorMoved()
   66   0.756765   0.007557  2()
   71   0.787226   0.005455  provider#clipboard#Call()
    7              0.003228  nvim_treesitter#indent()
    2              0.000571  HtmlIndent_CheckUserSettings()
    5              0.000271  1()
   12              0.000134  <SNR>30_dopopd()
    1   0.000075   0.000020  GuiClose()

